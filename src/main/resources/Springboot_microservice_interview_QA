Spring Boot Questions:

Asked in interview:
1. life cycle of a Bean in Spring Boot
    1. Bean Instantiation: Bean is created. @Component, @Service
    2. Dependency Injection: Dependencies are injected into the bean. @Autowired
    3. Bean Initialization: Custom initialization logic is executed.
    4. Bean Usage: The bean is ready to use.
    5. Bean Destruction: Cleanup logic is executed before the bean is removed. @PreDestroy

2. Explain Bean Scope ?
    In Spring, bean scope defines the lifecycle and visibility of a bean. It determines how the bean is created, shared,
    and used within the application context.

    Types of Bean Scopes
    1. Singleton (Default Scope) :
    Definition : Only one instance of the bean is created per Spring application context.
    When to Use: For stateless beans shared across the application, like configuration or utility beans or logs.
    Key Point: All requests share the same instance of the bean.
    example:
        @Scope("singleton")
        @Component
        public class MyBean { }

    2. Prototype :
    Definition: A new instance of the bean is created each time it is requested from the application context.
    When to Use: For stateful beans or beans with mutable data that should not be shared.
    example:
        @Scope("prototype")
        @Component
        public class MyBean { }

    3. Request (Web Application) :
    Definition: A new instance of the bean is created for each HTTP request.
    When to Use: For beans that handle HTTP request-specific data.
    Key Point: The bean lives only for the duration of the HTTP request.

    4. Session (Web Applications) :
    Definition: A new instance of the bean is created for each HTTP session.
    When to Use: For beans that maintain session-specific data like user preferences.
    Key Point: The bean is tied to the HTTP session and destroyed when the session ends.

    5. Application (Web Applications) :
    Definition: A single instance of the bean is created for the entire ServletContext.
    When to Use: For shared resources across all HTTP requests and sessions.

    6. Thread (Custom Scope) :
    Definition: A new instance of the bean is created for each thread.
    When to Use: For thread-specific tasks (e.g., in multi-threaded applications).


 Key Differences (Interview-Ready Table)
    Scope	        Instance Count	                    Lifetime	                    Usage
    --------------------------------------------------------------------------------------------------------------------
    Singleton	    1 per application	         Entire application lifecycle	        Stateless beans
    Prototype	    New per request	             Caller manages the bean's lifecycle	Stateful beans
    Request	        New per HTTP request	     HTTP request duration	                Request-specific beans (e.g., REST APIs)
    Session	        1 per HTTP session           HTTP session duration	                Session-specific beans
    Application	    1 per ServletContext	     ServletContext duration	            Shared web resources

------------------------------------------------------------------------------------------------------------------------
1. what is fallback method in microservice?
    Definition:
    A fallback method in a microservices architecture is a predefined mechanism that provides an alternative response or
    action when a service call fails or becomes unavailable due to issues such as timeouts, exceptions, or network failures.

    Fallback methods are part of resiliency patterns that ensure a microservices system remains functional and provides
    a degraded but meaningful user experience during failures.

    Spring Cloud Resilience4j (Recommended Post-Hystrix)
    Using Resilience4j, which is the modern replacement for Hystrix, you can implement fallback methods.
    example:
    @RestController
    public class PaymentController {

        @GetMapping("/processPayment")
        @Retry(name = "paymentService", fallbackMethod = "fallbackProcessPayment")
        public String processPayment() {
            // Simulated failure
            if (Math.random() > 0.5) {
                throw new RuntimeException("Payment gateway not responding");
            }
            return "Payment processed successfully";
        }

        // Fallback method
        public String fallbackProcessPayment(Exception e) {
            return "Payment service is unavailable. Please try again later.";
        }
    }
------------------------------------------------------------------------------------------------------------------------
2. what is dirty check in Hibernate?
    Definition:
    Dirty checking is a mechanism in Hibernate that automatically detects changes made to persistent objects and updates
    the database accordingly during a transaction commit, without requiring explicit update() calls from the developer.

------------------------------------------------------------------------------------------------------------------------
3. Create Rest Service and add Authentication to it?
    o implement a REST service with OAuth 2.0 authentication, we can use Spring Boot with Spring Security and integrate
    with an in-memory or external authorization server.

    Steps to Implement:
    1. Set Up the Spring Boot Application: Add dependencies for Spring Security and OAuth2.
    2. Authorization Server Configuration: Use Spring Boot to act as an OAuth2 Authorization Server.
    3. Protect REST Endpoints: Secure APIs using OAuth2.
    4. Test the Application: Use tools like Postman or curl to request a token and access secured endpoints.

    1. pom.xml
        <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-security</artifactId>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-security-oauth2-authorization-server</artifactId>
                <version>1.1.1</version>
        </dependency>

    2. Authorization Server Configuration
    The application will act as an OAuth 2.0 Authorization Server.

    @Configuration
    public class AuthorizationServerConfig {

        @Bean
        public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
            OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);
            return http.formLogin().and().build();
        }
    }

    3. Security Configuration:

    @Configuration
    public class SecurityConfig {

        @Bean
        public InMemoryUserDetailsManager userDetailsManager() {
            return new InMemoryUserDetailsManager(
                User.withUsername("client")
                    .password(passwordEncoder().encode("secret"))
                    .roles("USER")
                    .build()
            );
        }

        @Bean
        public PasswordEncoder passwordEncoder() {
            return new BCryptPasswordEncoder();
        }

        @Bean
        public void configureClients(AuthenticationManagerBuilder auth) throws Exception {
            auth.inMemoryAuthentication()
                .withUser("client")
                .password(passwordEncoder().encode("secret"))
                .roles("CLIENT");
        }
    }

    4. Protect the REST API
    @Configuration
    @EnableResourceServer
    public class ResourceServerConfig {

        @Bean
        public SecurityFilterChain resourceServerSecurityFilterChain(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                .antMatchers("/public/**").permitAll()
                .antMatchers("/secure/**").authenticated()
                .and()
                .oauth2ResourceServer()
                .jwt(); // Use JWT tokens for OAuth2
            return http.build();
        }
    }

    5. REST Controller

    @RestController
    @RequestMapping("/api")
    public class MyRestController {

        @GetMapping("/public")
        public String publicEndpoint() {
            return "This is a public endpoint!";
        }

        @GetMapping("/secure")
        public String secureEndpoint() {
            return "This is a secure endpoint, accessible only with a valid token!";
        }
    }

   How It Works:
    Public Endpoint: /api/public - Accessible without authentication.
    Secure Endpoint: /api/secure - Requires a valid OAuth2 token.
    Authorization Server:
    Client requests a token by providing credentials (e.g., client/secret).
    Server issues a JWT token upon successful authentication.
    Resource Server:
    Validates the token before granting access to protected resources.

------------------------------------------------------------------------------------------------------------------------
How do you est database connection in your application
    In my payment domain project, we used JPA (Java Persistence API) as the ORM tool to interact with the database.
    The database connection was established and managed through Spring Data JPA, which simplifies database operations
    and abstracts much of the boilerplate code. Here’s how the connection was set up and utilized:

    1. Database Configuration:
        The connection to the database was defined in the application.properties (or application.yml) file of the
        Spring Boot application. For example:

        # Database Connection Properties
        spring.datasource.url=jdbc:mysql://localhost:3306/paymentdb
        spring.datasource.username=payment_user
        spring.datasource.password=secure_password
        spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

        # JPA Hibernate Configuration
        spring.jpa.hibernate.ddl-auto=update
        spring.jpa.show-sql=true
        spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

    2. JPA Integration:
        JPA provided an abstraction over JDBC. Entities were mapped to database tables using annotations like @Entity,
        and Spring Data JPA repositories were used to perform CRUD operations

        @Entity
        public class PaymentTransaction {
            @Id
            @GeneratedValue
            private Long id;
            private String transactionId;
            private Double amount;
            private String status;
        }

        public interface PaymentTransactionRepository extends JpaRepository<PaymentTransaction, Long> {
            // Custom queries can be defined here if needed
        }

------------------------------------------------------------------------------------------------------------------------
Counter Question : What if there is a failure while interacting with the database? How do you handle it?
    1. Spring Transactions: We use the @Transactional annotation to ensure atomicity. If any part of the transaction fails,
       the entire operation is rolled back automatically.
    2. Custom Exception Handling: We handle database-specific exceptions like DataIntegrityViolationException or
       ConstraintViolationException and map them to appropriate application-level exceptions.
    3. Retries: In critical operations (e.g., payments), we implemented retry mechanisms using tools like Resilience4j
       or Spring Retry to handle transient database failures.

------------------------------------------------------------------------------------------------------------------------
Counter Question : How do you handle database schema changes in JPA?
    we used Hibernate’s spring.jpa.hibernate.ddl-auto property set to update for automatic schema updates.

------------------------------------------------------------------------------------------------------------------------
Explain dependency Injection with example?

    Key Concepts of Dependency Injection
        Dependency: An object on which another object depends.
        Injection: Supplying a dependency object to a dependent object.
        Inversion of Control (IoC): The control of object creation and lifecycle is transferred to a container.

    Types of Dependency Injection
        1. Constructor Injection: Dependencies are provided through the class constructor.
        2. Setter Injection: Dependencies are provided through public setter methods.
        3. Field Injection: Dependencies are injected directly into fields using annotations (like @Autowired in Spring).

    Without Dependency Injection:
        Public class PaymentService {
            private NotificationService notificationService;

            public PaymentService() {
                // Tightly coupled
                this.notificationService = new NotificationService();
            }

            public void processPayment() {
                System.out.println("Processing payment...");
                notificationService.sendNotification("Payment successful!");
            }
        }

        class NotificationService {
            public void sendNotification(String message) {
                System.out.println("Notification: " + message);
            }
        }

    With Dependency Injection:
        public class PaymentService {
            private NotificationService notificationService;

            // Dependency injected via constructor
            public PaymentService(NotificationService notificationService) {
                this.notificationService = notificationService;
            }
        }

    Dependency Injection in Spring Framework:
    Using @Autowired (Field Injection)

    @Service
    public class PaymentService {

        @Autowired
        private NotificationService notificationService;

        public void processPayment() {
            System.out.println("Processing payment...");
            notificationService.sendNotification("Payment successful!");
        }
    }

    Note: Constructor Injection is better
        Advantages:
        Mandatory dependencies: Ensures all required dependencies are provided when the object is created.
        Immutability: Encourages immutability as dependencies are final (can be declared as final).
        Testability: Great for unit testing as dependencies can be injected easily.
        Explicit contract: Makes dependencies visible in the constructor, improving code readability.


   Final Suggestion
   * Use Constructor Injection for clean, testable, and maintainable code.
   * If using Spring Framework, field injection with @Autowired can be quick,
   but it’s better to stick to constructor injection for larger projects to ensure clarity and immutability.

------------------------------------------------------------------------------------------------------------------------
How do you handle Exception in your project? what if an unknow error comes then how you handle it? what find of status
code you show to client?
answer:

    In my project, we use Spring Boot's Exception Handling mechanism to handle exceptions systematically and return
    meaningful responses to the client. Here's how:

    1. Global Exception Handling:
    We use @ControllerAdvice and @ExceptionHandler to manage exceptions centrally, ensuring a consistent response format.

    2. Custom Exceptions:
    For business logic, we define custom exceptions like PaymentNotFoundException or InvalidTransactionException,
    making error handling specific and clear.

    3. Unknown Errors:
    For unexpected exceptions, we handle them with a generic Exception handler in the global exception class.

    example:
        @ControllerAdvice
        public class GlobalExceptionHandler {

            @ExceptionHandler(PaymentNotFoundException.class)
            public ResponseEntity<String> handlePaymentNotFound(PaymentNotFoundException ex) {
                return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND); // 404
            }

            @ExceptionHandler(Exception.class)
            public ResponseEntity<String> handleGenericException(Exception ex) {
                return new ResponseEntity<>("An unexpected error occurred.", HttpStatus.INTERNAL_SERVER_ERROR); // 500
            }
        }

Status Codes Returned to Client:
400 (Bad Request): For validation errors or incorrect input.
404 (Not Found): For resources not found (e.g., invalid payment ID).
500 (Internal Server Error): For unknown errors or system failures.
401 (Unauthorized): If authentication fails.
403 (Forbidden): If the user is not allowed to access the resource

Counter Question: What If an Unknown Error Occurs?
   1.  We log the error using a logging framework like Logback or SLF4J for debugging and diagnostics.
   2.  Return a 500 Internal Server Error to the client with a user-friendly message:
    "Something went wrong. Please try again later."

------------------------------------------------------------------------------------------------------------------------
How will you configure your server to server for more request?
    Using Load balance like Nginx

------------------------------------------------------------------------------------------------------------------------
Suppose you have service performing transaction and another service which is checking balance, how you will handle this?
in what and all you can handle?
answer:
    Ways to Handle the Scenario
    1. Use same Database Transactions:
       If both services access the same database:

       Wrap transactional operations (debits/credits) in a database transaction to ensure atomicity.
       Use isolation levels (e.g., READ COMMITTED or REPEATABLE READ) to prevent dirty reads and ensure consistent balance checks.

    2. Use Distributed Transactions:
        Saga Pattern: Break the transaction into smaller steps managed by a coordinator.
        E.g., Debit account → Record transaction → Check balance.
        Pros: Ensures consistency across services. Cons: Complex to implement and manage.

    3. Event-Driven Architecture:
        Use an event-driven approach with a message broker (e.g., Kafka).
        The transaction service publishes an event (e.g., TransactionCompleted) after completing a transaction.
        The balance service listens to these events and updates a read-optimized cache for quick balance checks.

------------------------------------------------------------------------------------------------------------------------
How do you test Rest API, which has Authentication?
    Use Postman to test authentication by setting up Basic Auth or Bearer Token in the Authorization tab.

------------------------------------------------------------------------------------------------------------------------
Explain @MediaType ?
    @MediaType is an annotation used in JAX-RS (Java API for RESTful Web Services) to define the media type (MIME type)
    of the request or response. It helps specify the format in which the data is sent or received,
    such as application/json, application/xml, text/plain, etc.

    Key Points:
    Used for: Defining the content type for request or response in REST APIs.
    Commonly used in:
    @Produces: Specifies the media types that a method can return.
    @Consumes: Specifies the media types that a method can consume.

    @Path("/user")
    public class UserService {

        @GET
        @Path("/info")
        @Produces(MediaType.APPLICATION_JSON) // Response will be in JSON format
        public User getUserInfo() {
            return new User("John", "Doe");
        }

        @POST
        @Consumes(MediaType.APPLICATION_JSON) // Accepts JSON data in request body
        public Response createUser(User user) {
            // Process user creation
            return Response.status(201).build();
        }
    }



------------------------------------------------------------------------------------------------------------------------
1. What is Spring Boot, and why is it used?
Answer:
Spring Boot simplifies the development of Spring-based applications by providing:

-   Auto-configuration to eliminate boilerplate configuration code.
-   Embedded servers (e.g., Tomcat, Jetty) for running applications.
-   Production-ready features like Actuator for monitoring.
Example from Work:
    In your payment model, Spring Boot was used to create a Payment Service API with embedded Tomcat, enabling faster
deployment without external server configurations.

------------------------------------------------------------------------------------------------------------------------
1. What is Spring Boot, and how is it different from Spring Framework?
Answer:

Spring Boot simplifies the configuration of Spring applications by providing
    auto-configuration,
    embedded servers, and
    production-ready features.
It eliminates the need for XML-based configuration.

------------------------------------------------------------------------------------------------------------------------
2. Explain key annotations in Spring Boot and their uses.
Annotation	Description
    @SpringBootApplication : Combines @Configuration, @EnableAutoConfiguration, and @ComponentScan.
                             Entry point for Spring Boot applications.
           @RestController : Combines @Controller and @ResponseBody to simplify REST API creation.
           @RequestMapping : Maps HTTP requests to handler methods at the class or method level.
              @GetMapping,
              @PostMapping : Specialized annotations for HTTP GET and POST methods.
                @Autowired : Injects dependencies automatically using Spring's IoC container.
            @Configuration : Marks a class as a source of bean definitions for the application context.
                   @Entity : Marks a class as a JPA entity for database mapping.
               @Repository : Indicates a DAO component.
                  @Service : Marks a class as a service layer component.

------------------------------------------------------------------------------------------------------------------------
5. What is @EnableAutoConfiguration?
Answer:
This annotation allows Spring Boot to automatically configure beans based on dependencies in the classpath.

------------------------------------------------------------------------------------------------------------------------
6. How do you enable caching in Spring Boot?
Answer:

Use @EnableCaching to enable caching at the application class level.
Use @Cacheable, @CacheEvict, and @CachePut for specific caching operations method level.

    @EnableCaching
    @Configuration
    public class CacheConfig {
    }

    @Cacheable("payments")
    public Payment getPaymentById(String id) {
        // Simulated DB call
        return paymentRepository.findById(id).orElse(null);
    }


------------------------------------------------------------------------------------------------------------------------
2. How do you handle application configuration in Spring Boot?
Answer:
Spring Boot uses the application.properties or application.yml file to manage configurations such as database credentials,
port numbers, and custom properties.

Example:
In your payment system, properties like the payment gateway URL and credentials were stored in application.properties:

    payment.gateway.url=https://api.paymentgateway.com
    payment.gateway.apiKey=abcd1234
    server.port=8080

------------------------------------------------------------------------------------------------------------------------

3. How do you implement exception handling in Spring Boot?
Answer:
Use @ControllerAdvice and @ExceptionHandler to create a global exception-handling mechanism.

Example from Work:
For handling Payment Processing Errors, a global exception handler was created:

    @RestControllerAdvice
    public class GlobalExceptionHandler {
        @ExceptionHandler(PaymentFailedException.class)
        public ResponseEntity<String> handlePaymentFailure(PaymentFailedException ex) {
            return new ResponseEntity<>("Payment failed: " + ex.getMessage(), HttpStatus.BAD_REQUEST);
        }
    }

------------------------------------------------------------------------------------------------------------------------
4. What is Spring Boot Actuator, and how did you use it?
Answer:
Spring Boot Actuator provides endpoints to monitor and manage applications (e.g., /actuator/health, /actuator/metrics).

Example:
In your payment model, Actuator was used to monitor the health of the Payment Service:

------------------------------------------------------------------------------------------------------------------------
Microservices Questions

11. What are patterns used in microservices?
Answer:

Saga Pattern: Handles distributed transactions. and fall back mechanism
Circuit Breaker: Prevents cascading failures.
Bulkhead Pattern: Isolates failures to prevent system-wide crashes.

------------------------------------------------------------------------------------------------------------------------

5. What is the difference between Monolithic and Microservices Architectures?
Answer:

Monolithic: A single, tightly coupled codebase.
Microservices: Independent, loosely coupled services for different business functionalities.
Example:
In your work, you transitioned the Payment Module from a monolithic architecture to a microservice, allowing independent
scaling of payment processing during high traffic.

------------------------------------------------------------------------------------------------------------------------
6. How do microservices communicate with each other?
Answer:
Microservices communicate using:
    Synchronous: REST APIs or gRPC for real-time requests.
    Asynchronous: Messaging systems like Kafka or RabbitMQ for event-driven communication.
Example from Work:
The Payment Service communicated with the Order Service using REST APIs to update payment status and published events
like PaymentSuccess to Kafka for inventory updates.

------------------------------------------------------------------------------------------------------------------------

7. What is service discovery, and how is it implemented?
Answer:
Service discovery enables services to register and discover other services dynamically.
This is often implemented using Eureka in Spring Cloud.

Example:
In your e-commerce application, the Payment Service registered with Eureka:
    eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
    spring.application.name=payment-service

------------------------------------------------------------------------------------------------------------------------
8. How do you secure microservices?
Answer:

    Authentication/Authorization: Use OAuth 2.0 or JWT.
    Gateway Security: Secure APIs with API Gateway and rate limiting.
    Service-to-Service Security: Use mutual TLS or token-based authentication.
Example:
In your payment system, the API Gateway validated JWT tokens before forwarding requests to the Payment Service:

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests(auth -> auth.anyRequest().authenticated())
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
        return http.build();
    }

------------------------------------------------------------------------------------------------------------------------
REST API Questions

API Annotations
Annotation	    Purpose
-----------     --------
@PathVariable	Extracts values from the URI path.
@RequestParam	Extracts query parameters from the URL.
@RequestBody	Binds the HTTP request body to a method parameter.
@ResponseBody	Indicates that a method’s return value is serialized into the HTTP response body.
@CrossOrigin	Enables CORS for specific APIs.
@Valid	        Validates request payloads against constraints.
@ResponseStatus	Sets the HTTP status for a response.

------------------------------------------------------------------------------------------------------------------------

9. What are the key principles of REST?
Answer:

>> Statelessness: Each request is independent.
>> Client-Server Separation: The client and server remain decoupled.
>> Uniform Interface: Use consistent resource URIs (e.g., /payments).
>> Cacheable: Responses can be cached to improve performance.
>> Layered System: API calls can pass through intermediaries like gateways.

------------------------------------------------------------------------------------------------------------------------
10. How do you design RESTful APIs for the Payment System?
Answer:
Design resources as nouns and use HTTP methods like GET, POST, and DELETE.

Example:
    POST /payments
    Request Body: { "orderId": "123", "amount": 500.0 }
    Response: 201 Created

    GET /payments/{id}
    Response: { "paymentId": "456", "orderId": "123", "status": "SUCCESS" }

------------------------------------------------------------------------------------------------------------------------
11. How do you handle API versioning in REST APIs?
Answer:
Version APIs to avoid breaking changes. Use one of the following:

>> URI Versioning: /v1/payments
>> Header Versioning: Add Version: 1 in headers.
Example:
    @RequestMapping("/v1/payments")
    @RestController
    public class PaymentController {
        @PostMapping
        public ResponseEntity<String> processPayment(@RequestBody PaymentRequest request) {
            return ResponseEntity.ok("Payment processed for order: " + request.getOrderId());
        }
    }

------------------------------------------------------------------------------------------------------------------------
12. How do you test REST APIs?
Answer:

Unit Testing: Use JUnit and Mockito.
Integration Testing: Use Spring Boot's @SpringBootTest with tools like TestRestTemplate.
API Testing: Use Postman or automated tools like RestAssured.
Example of Integration Test for Payment API:

    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
    public class PaymentControllerTest {
        @Autowired
        private TestRestTemplate restTemplate;

        @Test
        public void testProcessPayment() {
            PaymentRequest request = new PaymentRequest("123", 500.0);
            ResponseEntity<String> response = restTemplate.postForEntity("/v1/payments", request, String.class);
            assertEquals(HttpStatus.OK, response.getStatusCode());
        }
    }

------------------------------------------------------------------------------------------------------------------------
13. How do you handle errors in REST APIs?
Answer:
Use standardized HTTP status codes and custom error responses:

400: Bad Request
404: Not Found
500: Internal Server Error
Example:
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public class PaymentNotFoundException extends RuntimeException {
        public PaymentNotFoundException(String message) {
            super(message);
        }
    }

Let’s discuss status codes with their meanings:

1xx – Informational Response (These status codes are all about the information received by the server when a request is made).
2xx – Success (This status code depicts that the request made has been fulfilled by the server and the expected response has been achieved).
    200 OK
    201 Created
    202 Accepted

3xx – Redirection (The requested URL is redirected elsewhere).
4xx – Client Errors (This indicates that the page is not found).
    400 Bad Request
    401 Unauthorized
    402 Payment Required
    403 Forbidden
    404 Not Found
    405 Method Not Allowed
    406 Not Acceptable
    407 Proxy Authentication Required
    408 Request Timeout
    409 Conflict

5xx – Server Errors (A request made by the client but the server fails to complete the request).
    500 Internal Server Error
    501 Not Implemented
    502 Bad Gateway

------------------------------------------------------------------------------------------------------------------------
14. What are Idempotency and its importance in REST APIs?
Answer:
Idempotency ensures that making the same request multiple times produces the same result.
Example: Payment requests are idempotent to avoid duplicate charges:
    @PostMapping("/payments")
    public ResponseEntity<String> processPayment(@RequestBody PaymentRequest request) {
        if (paymentExists(request.getOrderId())) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body("Payment already processed.");
        }
        return ResponseEntity.ok("Payment processed.");
    }

------------------------------------------------------------------------------------------------------------------------
WebClient

1. What is WebClient in Spring?
Answer:
    * WebClient is a non-blocking, reactive HTTP client introduced in Spring WebFlux.
    * It is an alternative to the older RestTemplate
    * supports asynchronous communication.

------------------------------------------------------------------------------------------------------------------------
2. What are the advantages of using WebClient over RestTemplate?
Answer:

    1. Reactive and Non-blocking: Suitable for high-throughput applications.
    2. Supports Asynchronous Calls: Ideal for APIs with long response times.
    3. Streaming: Can handle large responses in a streaming manner.
    4. Functional API: More flexible and concise than RestTemplate.

------------------------------------------------------------------------------------------------------------------------
3. How do you configure a WebClient?
Answer:
    You can configure WebClient using the WebClient.Builder.

Example:
    @Bean
    public WebClient webClient(WebClient.Builder builder) {
        return builder
                .baseUrl("https://api.paymentgateway.com")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

------------------------------------------------------------------------------------------------------------------------
4. What are the key methods of WebClient?
Answer:
    Method	Purpose
    get()	Makes an HTTP GET request.
    post()	Makes an HTTP POST request.
    retrieve()	Fetches the response body and handles errors.
    exchangeToMono()	Provides full control over the response.
    bodyToMono()	Maps the response body to a Mono.
    onStatus()	Handles HTTP status-specific errors.

------------------------------------------------------------------------------------------------------------------------
5. How do you handle errors in WebClient?
Answer:
Use onStatus() to handle HTTP status codes and transform them into exceptions.

Example from Work:
In the Payment Service, handle HTTP 400 (Bad Request) and HTTP 500 (Server Error) from the Payment Gateway:
    WebClient webClient = WebClient.create();

    public String processPayment(String orderId, double amount) {
        return webClient.post()
                .uri("/payments")
                .bodyValue(new PaymentRequest(orderId, amount))
                .retrieve()
                .onStatus(HttpStatus::is4xxClientError, clientResponse ->
                    Mono.error(new RuntimeException("Client error occurred")))
                .onStatus(HttpStatus::is5xxServerError, clientResponse ->
                    Mono.error(new RuntimeException("Server error occurred")))
                .bodyToMono(String.class)
                .block();
    }

------------------------------------------------------------------------------------------------------------------------
6. How do you make a POST request using WebClient?
Answer:
Use the post() method and provide the request body using bodyValue().

Example from Work:
Send a payment request to an external Payment Gateway:
    public String initiatePayment(String orderId, double amount) {
        return webClient.post()
                .uri("/payments")
                .bodyValue(new PaymentRequest(orderId, amount))
                .retrieve()
                .bodyToMono(String.class)
                .block();
    }

------------------------------------------------------------------------------------------------------------------------
7. How do you perform asynchronous calls with WebClient?
Answer:
WebClient returns a Mono or Flux, which you can "subscribe" to for asynchronous handling.

Example from Work:
In the Payment Service, asynchronously notify the Order Service after payment success:

    public void notifyOrderService(String orderId) {
        webClient.post()
                .uri("/orders/{id}/notify", orderId)
                .retrieve()
                .bodyToMono(Void.class)
                .subscribe(response -> System.out.println("Order notified successfully"),
                           error -> System.err.println("Error notifying order: " + error.getMessage()));
    }

------------------------------------------------------------------------------------------------------------------------
8. How do you log WebClient requests and responses?
Answer:
Use a filter to log WebClient activity.

Example from Work:
Log payment requests and responses for debugging:

    @Bean
    public WebClient webClient(WebClient.Builder builder) {
        return builder
                .baseUrl("https://api.paymentgateway.com")
                .filter((request, next) -> {
                    System.out.println("Request: " + request.url());
                    return next.exchange(request)
                               .doOnNext(response -> System.out.println("Response: " + response.statusCode()));
                })
                .build();
    }

------------------------------------------------------------------------------------------------------------------------
9. How do you handle timeouts in WebClient?
Answer:
Use a timeout() operator to limit the time for responses.

Example from Work:
Set a timeout for payment gateway responses to avoid blocking:
    public String processPaymentWithTimeout(String orderId, double amount) {
        return webClient.post()
                .uri("/payments")
                .bodyValue(new PaymentRequest(orderId, amount))
                .retrieve()
                .bodyToMono(String.class)
                .timeout(Duration.ofSeconds(5))
                .onErrorResume(TimeoutException.class, e -> Mono.just("Payment service timeout"))
                .block();
    }

------------------------------------------------------------------------------------------------------------------------
10. How do you use WebClient in reactive microservices?
Answer:
WebClient is ideal for non-blocking inter-service communication in microservices.

Example from Work:
The Order Service calls the Payment Service to confirm the payment status:

    public Mono<String> confirmPayment(String paymentId) {
        return webClient.get()
                .uri("/payments/{id}", paymentId)
                .retrieve()
                .bodyToMono(String.class);
    }

------------------------------------------------------------------------------------------------------------------------
11. How do you handle backpressure with WebClient?
Answer:
Use Flux to manage streaming responses and apply backpressure techniques like limiting the rate of requests.

Example from Work:
Handle a large response from the payment history API in chunks:
    public Flux<PaymentHistory> getPaymentHistory() {
        return webClient.get()
                .uri("/payments/history")
                .retrieve()
                .bodyToFlux(PaymentHistory.class)
                .limitRate(10); // Process 10 items at a time
    }

------------------------------------------------------------------------------------------------------------------------
